/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/core/BeraMap.js":
/*!***********************************!*\
  !*** ./assets/js/core/BeraMap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BeraMap: () => (/* binding */ BeraMap),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _managers_GeoManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../managers/GeoManager.js */ "./assets/js/managers/GeoManager.js");
/* harmony import */ var _managers_EventManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../managers/EventManager.js */ "./assets/js/managers/EventManager.js");
/* harmony import */ var _renderers_PointRenderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderers/PointRenderer.js */ "./assets/js/renderers/PointRenderer.js");
/* harmony import */ var _renderers_LineRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderers/LineRenderer.js */ "./assets/js/renderers/LineRenderer.js");
/* harmony import */ var _renderers_PolygonRenderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderers/PolygonRenderer.js */ "./assets/js/renderers/PolygonRenderer.js");
/* harmony import */ var _renderers_CircleRenderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../renderers/CircleRenderer.js */ "./assets/js/renderers/CircleRenderer.js");
/* harmony import */ var _renderers_DrawingRenderer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../renderers/DrawingRenderer.js */ "./assets/js/renderers/DrawingRenderer.js");
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/constants.js */ "./assets/js/utils/constants.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * BeraMap - Plugin Leaflet Modular para Porto Velho, Rondônia
 *
 * Classe principal que orquestra:
 * - GeoManager (gerenciar geometrias)
 * - EventManager (gerenciar eventos)
 * - Renderers (renderizar geometrias)
 */









var BeraMap = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {string} containerId - ID do container do mapa
   * @param {Object} options - Opções de configuração
   */
  function BeraMap(containerId) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, BeraMap);
    if (!window.L) {
      throw new Error('BeraMap: Leaflet não foi carregado');
    }
    this.L = window.L;
    this._containerId = containerId;
    this._config = this._mergeConfig(_utils_constants_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_CONFIG, options);
    this._map = null;
    this._layerGroups = {};
    this._geoManager = null;
    this._eventManager = null;
    this._renderers = {};
    this._initialized = false;
    this._initialize();
  }

  /**
   * Inicializa o mapa e componentes
   * @private
   */
  return _createClass(BeraMap, [{
    key: "_initialize",
    value: function _initialize() {
      try {
        // Criar mapa Leaflet
        this._map = this.L.map(this._containerId).setView(this._config.center, this._config.zoom);

        // Adicionar tile layer
        this.L.tileLayer(this._config.tileLayer, {
          attribution: this._config.tileAttribution
        }).addTo(this._map);

        // Inicializar layer groups
        this._initializeLayerGroups();

        // Inicializar managers e renderers
        this._initializeManagers();
        this._initialized = true;
        console.log('✅ BeraMap v' + _utils_constants_js__WEBPACK_IMPORTED_MODULE_7__.VERSION + ' inicializado com sucesso');
      } catch (error) {
        console.error('❌ Erro ao inicializar BeraMap:', error);
        throw error;
      }
    }

    /**
     * Inicializa os layer groups
     * @private
     */
  }, {
    key: "_initializeLayerGroups",
    value: function _initializeLayerGroups() {
      var _this = this;
      var geometryTypes = Object.values(_utils_constants_js__WEBPACK_IMPORTED_MODULE_7__.GEOMETRY_TYPES);
      geometryTypes.forEach(function (type) {
        _this._layerGroups[type] = _this.L.layerGroup().addTo(_this._map);
      });
    }

    /**
     * Inicializa managers e renderers
     * @private
     */
  }, {
    key: "_initializeManagers",
    value: function _initializeManagers() {
      this._eventManager = new _managers_EventManager_js__WEBPACK_IMPORTED_MODULE_1__.EventManager(this);
      this._geoManager = new _managers_GeoManager_js__WEBPACK_IMPORTED_MODULE_0__.GeoManager(this);
      this._renderers = {
        Point: new _renderers_PointRenderer_js__WEBPACK_IMPORTED_MODULE_2__.PointRenderer(this),
        LineString: new _renderers_LineRenderer_js__WEBPACK_IMPORTED_MODULE_3__.LineRenderer(this),
        Polygon: new _renderers_PolygonRenderer_js__WEBPACK_IMPORTED_MODULE_4__.PolygonRenderer(this),
        Circle: new _renderers_CircleRenderer_js__WEBPACK_IMPORTED_MODULE_5__.CircleRenderer(this),
        Drawing: new _renderers_DrawingRenderer_js__WEBPACK_IMPORTED_MODULE_6__.DrawingRenderer(this)
      };
    }

    /**
     * Adiciona geometrias ao mapa
     * @param {Object} geojson - FeatureCollection ou Feature
     * @param {Object} options - Opções adicionais
     * @returns {Array} Array de UUIDs adicionados
     */
  }, {
    key: "addGeometries",
    value: function addGeometries(geojson) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this._initialized) {
        console.error('BeraMap: plugin não inicializado');
        return [];
      }
      try {
        var features = this._normalizeFeatures(geojson);
        if (!features || features.length === 0) {
          console.warn('BeraMap: nenhuma feature para adicionar');
          return [];
        }
        var addedUUIDs = [];
        features.forEach(function (feature) {
          var uuid = _this2._geoManager.addGeometry(feature);
          var geometryType = feature.geometry.type;
          if (_this2._renderers[geometryType]) {
            _this2._renderers[geometryType].render(uuid, feature);
          }
          addedUUIDs.push(uuid);
        });
        this._eventManager.trigger('bera:geometryAdded', {
          uuids: addedUUIDs,
          count: addedUUIDs.length
        });
        if (options.fitBounds) {
          this.fitBounds(addedUUIDs);
        }
        return addedUUIDs;
      } catch (error) {
        console.error('❌ Erro ao adicionar geometrias:', error);
        return [];
      }
    }

    /**
     * Atualiza geometrias
     * @param {Object} geojson - FeatureCollection ou Feature
     * @param {Object} options - Opções adicionais
     * @returns {Array} Array de UUIDs atualizados
     */
  }, {
    key: "updateGeometries",
    value: function updateGeometries(geojson) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this._initialized) {
        console.error('BeraMap: plugin não inicializado');
        return [];
      }
      try {
        var features = this._normalizeFeatures(geojson);
        if (!features || features.length === 0) {
          console.warn('BeraMap: nenhuma feature para atualizar');
          return [];
        }
        if (options.clearPrevious) {
          this.clearAll();
        }
        var updatedUUIDs = this.addGeometries(geojson, options);
        this._eventManager.trigger('bera:geometryUpdated', {
          uuids: updatedUUIDs,
          count: updatedUUIDs.length
        });
        return updatedUUIDs;
      } catch (error) {
        console.error('❌ Erro ao atualizar geometrias:', error);
        return [];
      }
    }

    /**
     * Remove geometrias
     * @param {string|Array} uuids - UUID ou array de UUIDs
     * @returns {boolean} Sucesso
     */
  }, {
    key: "removeGeometries",
    value: function removeGeometries(uuids) {
      var _this3 = this;
      if (!this._initialized) {
        console.error('BeraMap: plugin não inicializado');
        return false;
      }
      var uuidArray = Array.isArray(uuids) ? uuids : [uuids];
      try {
        var removedUUIDs = [];
        uuidArray.forEach(function (uuid) {
          var geometryData = _this3._geoManager.getGeometryByUUID(uuid);
          if (geometryData) {
            var geometryType = geometryData.feature.geometry.type;
            if (_this3._renderers[geometryType]) {
              _this3._renderers[geometryType].remove(uuid);
            }
            _this3._geoManager.removeGeometry(uuid);
            removedUUIDs.push(uuid);
          }
        });
        if (removedUUIDs.length > 0) {
          this._eventManager.trigger('bera:geometryRemoved', {
            uuids: removedUUIDs,
            count: removedUUIDs.length
          });
        }
        return removedUUIDs.length === uuidArray.length;
      } catch (error) {
        console.error('❌ Erro ao remover geometrias:', error);
        return false;
      }
    }

    /**
     * Limpa todas as geometrias
     * @returns {void}
     */
  }, {
    key: "clearAll",
    value: function clearAll() {
      if (!this._initialized) {
        console.error('BeraMap: plugin não inicializado');
        return;
      }
      try {
        Object.values(this._layerGroups).forEach(function (layerGroup) {
          layerGroup.clearLayers();
        });
        this._geoManager.clear();
        this._eventManager.trigger('bera:cleared', {});
        console.log('✅ Todas as geometrias foram removidas');
      } catch (error) {
        console.error('❌ Erro ao limpar mapa:', error);
      }
    }

    /**
     * Encaixa o mapa aos bounds das geometrias
     * @param {Array} uuids - Array de UUIDs (opcional)
     * @returns {void}
     */
  }, {
    key: "fitBounds",
    value: function fitBounds(uuids) {
      var _this4 = this;
      if (!uuids || uuids.length === 0) {
        uuids = this._geoManager.getUUIDs();
      }
      if (uuids.length === 0) {
        console.warn('BeraMap: nenhuma geometria para encaixar');
        return;
      }
      var bounds = this.L.latLngBounds([]);
      uuids.forEach(function (uuid) {
        var geometryData = _this4._geoManager.getGeometryByUUID(uuid);
        if (geometryData && geometryData.leafletLayer) {
          if (typeof geometryData.leafletLayer.getBounds === 'function') {
            bounds.extend(geometryData.leafletLayer.getBounds());
          } else if (typeof geometryData.leafletLayer.getLatLng === 'function') {
            bounds.extend(geometryData.leafletLayer.getLatLng());
          }
        }
      });
      if (bounds.isValid()) {
        this._map.fitBounds(bounds, {
          padding: [50, 50]
        });
      }
    }

    /**
     * Registra um listener de evento
     * @param {string} eventName - Nome do evento
     * @param {Function} callback - Callback
     * @param {Object} context - Contexto (this)
     * @returns {void}
     */
  }, {
    key: "on",
    value: function on(eventName, callback, context) {
      this._eventManager.on(eventName, callback, context);
    }

    /**
     * Remove um listener de evento
     * @param {string} eventName - Nome do evento
     * @param {Function} callback - Callback
     * @returns {void}
     */
  }, {
    key: "off",
    value: function off(eventName, callback) {
      this._eventManager.off(eventName, callback);
    }

    /**
     * Obtém uma geometria pelo UUID
     * @param {string} uuid - UUID
     * @returns {Object|null} Dados da geometria
     */
  }, {
    key: "getGeometryByUUID",
    value: function getGeometryByUUID(uuid) {
      return this._geoManager.getGeometryByUUID(uuid);
    }

    /**
     * Obtém todas as geometrias
     * @returns {Array} Array de geometrias
     */
  }, {
    key: "getAllGeometries",
    value: function getAllGeometries() {
      return this._geoManager.getAllGeometries();
    }

    /**
     * Obtém geometrias filtradas por tipo
     * @param {string} type - Tipo de geometria
     * @returns {Array} Array de geometrias
     */
  }, {
    key: "getGeometriesByType",
    value: function getGeometriesByType(type) {
      return this._geoManager.getGeometriesByType(type);
    }

    /**
     * Obtém contagem de geometrias
     * @returns {number} Quantidade
     */
  }, {
    key: "getGeometriesCount",
    value: function getGeometriesCount() {
      return this._geoManager.getCount();
    }

    /**
     * Obtém estatísticas
     * @returns {Object} Estatísticas
     */
  }, {
    key: "getStats",
    value: function getStats() {
      return this._geoManager.getStats();
    }

    /**
     * Exporta como GeoJSON
     * @returns {Object} FeatureCollection
     */
  }, {
    key: "exportGeoJSON",
    value: function exportGeoJSON() {
      return this._geoManager.exportAsGeoJSON();
    }

    /**
     * Obtém a instância do Leaflet map
     * @returns {Object} Mapa Leaflet
     */
  }, {
    key: "getLeafletMap",
    value: function getLeafletMap() {
      return this._map;
    }

    /**
     * Obtém um renderer específico
     * @param {string} geometryType - Tipo de geometria
     * @returns {Object|null} Renderer
     */
  }, {
    key: "getRenderer",
    value: function getRenderer(geometryType) {
      return this._renderers[geometryType] || null;
    }

    /**
     * Obtém todos os renderers
     * @returns {Object} Objeto com todos os renderers
     */
  }, {
    key: "getRenderers",
    value: function getRenderers() {
      return Object.assign({}, this._renderers);
    }

    /**
     * Obtém o GeoManager
     * @returns {Object} GeoManager
     */
  }, {
    key: "getGeoManager",
    value: function getGeoManager() {
      return this._geoManager;
    }

    /**
     * Obtém o EventManager
     * @returns {Object} EventManager
     */
  }, {
    key: "getEventManager",
    value: function getEventManager() {
      return this._eventManager;
    }

    /**
     * Verifica se foi inicializado
     * @returns {boolean}
     */
  }, {
    key: "isInitialized",
    value: function isInitialized() {
      return this._initialized;
    }

    /**
     * Obtém versão
     * @returns {string} Versão
     */
  }, {
    key: "getVersion",
    value: function getVersion() {
      return _utils_constants_js__WEBPACK_IMPORTED_MODULE_7__.VERSION;
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_normalizeFeatures",
    value: function _normalizeFeatures(geojson) {
      if (!geojson) return [];
      if (geojson.type === 'FeatureCollection' && Array.isArray(geojson.features)) {
        return geojson.features;
      }
      if (geojson.type === 'Feature') {
        return [geojson];
      }
      return [];
    }
  }, {
    key: "_mergeConfig",
    value: function _mergeConfig(defaults, options) {
      return Object.assign({}, defaults, options || {});
    }
  }]);
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BeraMap);

/***/ }),

/***/ "./assets/js/managers/EventManager.js":
/*!********************************************!*\
  !*** ./assets/js/managers/EventManager.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventManager: () => (/* binding */ EventManager),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/constants.js */ "./assets/js/utils/constants.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * EventManager - Gerenciador de Eventos para BeraMap
 *
 * Responsável por:
 * - Centralizar disparo de eventos jQuery
 * - Gerenciar listeners registrados
 * - Usar namespacing para evitar conflitos
 * - Fornecer interface simples on/off/trigger
 * - Logar eventos para debug
 */


var EventManager = /*#__PURE__*/function () {
  function EventManager(beraMap) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, EventManager);
    if (!window.jQuery && !window.$) {
      throw new Error('EventManager: jQuery não foi carregado');
    }
    this.$ = window.jQuery || window.$;
    this.beraMap = beraMap;
    this.config = {
      debug: options.debug || false,
      namespace: options.namespace || 'bera',
      useBubbling: options.useBubbling !== false,
      useCapture: options.useCapture || false
    };
    this.$eventTarget = options.$target || this.$(document);
    this.listeners = {};
    this.EVENTS = _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.EVENTS;
    this.eventHistory = [];
    this.maxHistorySize = options.maxHistorySize || 100;
    this._initialize();
  }
  return _createClass(EventManager, [{
    key: "_initialize",
    value: function _initialize() {
      console.log('✅ EventManager inicializado');
      console.log('   Namespace: ' + this.config.namespace);
      console.log('   Debug: ' + (this.config.debug ? 'ON' : 'OFF'));
    }

    /**
     * Registra um listener para um evento
     * @param {string} eventName - Nome do evento
     * @param {Function} callback - Função callback
     * @param {Object} context - Contexto (this) do callback
     * @returns {Function} Função para desinscrever
     */
  }, {
    key: "on",
    value: function on(eventName, callback, context) {
      var _this = this;
      if (!eventName || typeof callback !== 'function') {
        console.error('❌ EventManager.on(): eventName e callback obrigatórios');
        return null;
      }
      var boundCallback = context ? callback.bind(context) : callback;
      this._registerListener(eventName, boundCallback);
      this.$eventTarget.on(eventName, function (event, data) {
        boundCallback(event, data);
      });
      return function () {
        return _this.off(eventName, callback);
      };
    }

    /**
     * Registra um listener que será executado uma única vez
     * @param {string} eventName - Nome do evento
     * @param {Function} callback - Função callback
     * @param {Object} context - Contexto (this) do callback
     * @returns {Function} Função para desinscrever
     */
  }, {
    key: "once",
    value: function once(eventName, callback, context) {
      if (!eventName || typeof callback !== 'function') {
        console.error('❌ EventManager.once(): eventName e callback obrigatórios');
        return null;
      }
      var self = this;
      var _wrappedCallback = function wrappedCallback(event, data) {
        callback.call(context, event, data);
        self.off(eventName, _wrappedCallback);
      };
      return this.on(eventName, _wrappedCallback, context);
    }

    /**
     * Remove um listener
     * @param {string} eventName - Nome do evento
     * @param {Function} callback - Callback (opcional)
     * @returns {void}
     */
  }, {
    key: "off",
    value: function off(eventName, callback) {
      if (!eventName) {
        console.warn('⚠️ EventManager.off(): eventName obrigatório');
        return;
      }
      if (!callback) {
        this.$eventTarget.off(eventName);
        this._unregisterListener(eventName);
        return;
      }
      this.$eventTarget.off(eventName, callback);
      this._unregisterListener(eventName, callback);
    }

    /**
     * Remove todos os listeners
     * @returns {void}
     */
  }, {
    key: "offAll",
    value: function offAll() {
      var _this2 = this;
      var eventNames = Object.values(this.EVENTS);
      eventNames.forEach(function (eventName) {
        _this2.$eventTarget.off(eventName);
      });
      this.listeners = {};
      console.log('✅ EventManager: Todos os listeners removidos');
    }

    /**
     * Dispara um evento
     * @param {string} eventName - Nome do evento
     * @param {Object} data - Dados do evento
     * @returns {Object} Evento disparado
     */
  }, {
    key: "trigger",
    value: function trigger(eventName, data) {
      if (!eventName) {
        console.error('❌ EventManager.trigger(): eventName obrigatório');
        return null;
      }
      var eventData = Object.assign({}, data || {}, {
        timestamp: new Date().toISOString(),
        eventName: eventName
      });
      if (this.config.debug) {
        console.log('📢 EVENT DISPATCHED:', eventName, eventData);
      }
      this._addToHistory(eventName, eventData);
      return this.$eventTarget.trigger(eventName, [eventData]);
    }

    /**
     * Dispara múltiplos eventos em sequência
     * @param {Array} events - Array de { eventName, data }
     * @param {number} delayMs - Delay entre eventos
     * @returns {Promise} Promise que resolve quando todos disparados
     */
  }, {
    key: "triggerSequence",
    value: function triggerSequence(events) {
      var _this3 = this;
      var delayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return new Promise(function (resolve) {
        var index = 0;
        var _dispatchNext = function dispatchNext() {
          if (index < events.length) {
            var _events$index = events[index],
              eventName = _events$index.eventName,
              data = _events$index.data;
            _this3.trigger(eventName, data);
            index++;
            if (index < events.length) {
              setTimeout(_dispatchNext, delayMs);
            } else {
              resolve();
            }
          } else {
            resolve();
          }
        };
        _dispatchNext();
      });
    }

    /**
     * Dispara evento de geometria adicionada
     * @param {Array} uuids - UUIDs das geometrias
     * @param {Object} data - Dados adicionais
     */
  }, {
    key: "triggerGeometryAdded",
    value: function triggerGeometryAdded(uuids) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.trigger(this.EVENTS.GEOMETRY_ADDED, _objectSpread({
        uuids: uuids,
        count: Array.isArray(uuids) ? uuids.length : 1
      }, data));
    }

    /**
     * Dispara evento de geometria atualizada
     * @param {Array} uuids - UUIDs das geometrias
     * @param {Object} data - Dados adicionais
     */
  }, {
    key: "triggerGeometryUpdated",
    value: function triggerGeometryUpdated(uuids) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.trigger(this.EVENTS.GEOMETRY_UPDATED, _objectSpread({
        uuids: uuids,
        count: Array.isArray(uuids) ? uuids.length : 1
      }, data));
    }

    /**
     * Dispara evento de geometria removida
     * @param {Array} uuids - UUIDs das geometrias
     * @param {Object} data - Dados adicionais
     */
  }, {
    key: "triggerGeometryRemoved",
    value: function triggerGeometryRemoved(uuids) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.trigger(this.EVENTS.GEOMETRY_REMOVED, _objectSpread({
        uuids: uuids,
        count: Array.isArray(uuids) ? uuids.length : 1
      }, data));
    }

    /**
     * Dispara evento de geometria clicada
     * @param {string} uuid - UUID da geometria
     * @param {Object} geometry - Dados da geometria
     * @param {Object} leafletEvent - Evento do Leaflet
     */
  }, {
    key: "triggerGeometryClicked",
    value: function triggerGeometryClicked(uuid, geometry) {
      var leafletEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.trigger(this.EVENTS.GEOMETRY_CLICKED, {
        uuid: uuid,
        geometry: geometry,
        leafletEvent: leafletEvent
      });
    }

    /**
     * Dispara evento de geometria com hover
     * @param {string} uuid - UUID
     * @param {Object} geometry - Dados da geometria
     */
  }, {
    key: "triggerGeometryHovered",
    value: function triggerGeometryHovered(uuid, geometry) {
      this.trigger(this.EVENTS.GEOMETRY_HOVERED, {
        uuid: uuid,
        geometry: geometry
      });
    }

    /**
     * Dispara evento de geometria sem hover
     * @param {string} uuid - UUID
     * @param {Object} geometry - Dados da geometria
     */
  }, {
    key: "triggerGeometryUnhovered",
    value: function triggerGeometryUnhovered(uuid, geometry) {
      this.trigger(this.EVENTS.GEOMETRY_UNHOVERED, {
        uuid: uuid,
        geometry: geometry
      });
    }

    /**
     * Dispara evento de mapa limpo
     * @param {Object} data - Dados adicionais
     */
  }, {
    key: "triggerMapCleared",
    value: function triggerMapCleared() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.trigger(this.EVENTS.MAP_CLEARED, _objectSpread({
        clearedAt: new Date().toISOString()
      }, data));
    }

    /**
     * Dispara evento de mapa pronto
     * @param {Object} data - Dados adicionais
     */
  }, {
    key: "triggerMapReady",
    value: function triggerMapReady() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.trigger(this.EVENTS.MAP_READY, _objectSpread({
        readyAt: new Date().toISOString()
      }, data));
    }

    /**
     * Dispara evento de erro
     * @param {string} message - Mensagem de erro
     * @param {Error} error - Objeto de erro
     */
  }, {
    key: "triggerError",
    value: function triggerError(message) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.trigger(this.EVENTS.ERROR, {
        message: message,
        error: error,
        errorAt: new Date().toISOString()
      });
    }

    /**
     * Ativa/desativa debug
     * @param {boolean} enabled - Ativar ou desativar
     */
  }, {
    key: "setDebug",
    value: function setDebug(enabled) {
      this.config.debug = enabled;
      console.log('🔧 EventManager debug: ' + (enabled ? 'ON' : 'OFF'));
    }

    /**
     * Obtém histórico de eventos
     * @param {Object} options - Opções de filtro
     * @returns {Array} Array de eventos históricos
     */
  }, {
    key: "getEventHistory",
    value: function getEventHistory() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var history = this.eventHistory;
      if (options.eventName) {
        history = history.filter(function (h) {
          return h.eventName === options.eventName;
        });
      }
      if (options.limit) {
        history = history.slice(-options.limit);
      }
      return history;
    }

    /**
     * Limpa histórico de eventos
     * @returns {number} Quantidade removida
     */
  }, {
    key: "clearEventHistory",
    value: function clearEventHistory() {
      var count = this.eventHistory.length;
      this.eventHistory = [];
      return count;
    }

    /**
     * Obtém estatísticas de eventos
     * @returns {Object} Estatísticas
     */
  }, {
    key: "getEventStats",
    value: function getEventStats() {
      var stats = {
        totalEvents: this.eventHistory.length,
        byEventType: {},
        firstEventAt: null,
        lastEventAt: null
      };
      this.eventHistory.forEach(function (entry) {
        if (!stats.byEventType[entry.eventName]) {
          stats.byEventType[entry.eventName] = 0;
        }
        stats.byEventType[entry.eventName]++;
      });
      if (this.eventHistory.length > 0) {
        stats.firstEventAt = this.eventHistory[0].timestamp;
        stats.lastEventAt = this.eventHistory[this.eventHistory.length - 1].timestamp;
      }
      return stats;
    }

    /**
     * Obtém listeners registrados
     * @param {string} eventName - Nome do evento (opcional)
     * @returns {Object|Array} Listeners
     */
  }, {
    key: "getListeners",
    value: function getListeners() {
      var eventName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (eventName) {
        return this.listeners[eventName] || [];
      }
      return Object.assign({}, this.listeners);
    }

    /**
     * Conta listeners registrados
     * @param {string} eventName - Nome do evento (opcional)
     * @returns {number} Quantidade
     */
  }, {
    key: "getListenerCount",
    value: function getListenerCount() {
      var eventName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (eventName) {
        return (this.listeners[eventName] || []).length;
      }
      var total = 0;
      Object.values(this.listeners).forEach(function (listeners) {
        total += listeners.length;
      });
      return total;
    }

    /**
     * Imprime relatório no console
     * @returns {void}
     */
  }, {
    key: "printReport",
    value: function printReport() {
      console.group('📊 EventManager Report');
      var stats = this.getEventStats();
      console.log('Total de eventos disparados:', stats.totalEvents);
      if (stats.firstEventAt) {
        console.log('Primeiro evento:', stats.firstEventAt);
        console.log('Último evento:', stats.lastEventAt);
      }
      console.log('Eventos por tipo:');
      Object.entries(stats.byEventType).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          eventName = _ref2[0],
          count = _ref2[1];
        console.log('  - ' + eventName + ': ' + count);
      });
      console.log('Listeners registrados:', this.getListenerCount());
      console.groupEnd();
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_registerListener",
    value: function _registerListener(eventName, callback) {
      if (!this.listeners[eventName]) {
        this.listeners[eventName] = [];
      }
      this.listeners[eventName].push({
        callback: callback,
        registeredAt: new Date().toISOString()
      });
      if (this.config.debug) {
        console.log('✅ Listener registrado para:', eventName);
      }
    }
  }, {
    key: "_unregisterListener",
    value: function _unregisterListener(eventName) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!this.listeners[eventName]) {
        return;
      }
      if (!callback) {
        delete this.listeners[eventName];
        if (this.config.debug) {
          console.log('✅ Todos os listeners removidos para:', eventName);
        }
        return;
      }
      this.listeners[eventName] = this.listeners[eventName].filter(function (listener) {
        return listener.callback !== callback;
      });
      if (this.config.debug) {
        console.log('✅ Listener removido para:', eventName);
      }
    }
  }, {
    key: "_addToHistory",
    value: function _addToHistory(eventName, data) {
      this.eventHistory.push({
        eventName: eventName,
        timestamp: new Date().toISOString(),
        data: Object.assign({}, data)
      });
      if (this.eventHistory.length > this.maxHistorySize) {
        this.eventHistory.shift();
      }
    }
  }]);
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventManager);

/***/ }),

/***/ "./assets/js/managers/GeoManager.js":
/*!******************************************!*\
  !*** ./assets/js/managers/GeoManager.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeoManager: () => (/* binding */ GeoManager),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/constants.js */ "./assets/js/utils/constants.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * GeoManager - Gerenciador de Geometrias para BeraMap
 *
 * Responsável por:
 * - Armazenar e rastrear todas as geometrias por UUID
 * - Manter referências às camadas Leaflet renderizadas
 * - Fornecer interface de busca e query
 * - Gerenciar metadados de geometrias
 * - Validar dados de entrada
 */


var GeoManager = /*#__PURE__*/function () {
  function GeoManager(beraMap) {
    _classCallCheck(this, GeoManager);
    this.beraMap = beraMap;
    this.geometries = {};
    this.indexByType = {};
    this.indexByUUID = {};
    this.stats = {
      totalCount: 0,
      countByType: {}
    };
    this._boundsCache = null;
    this._boundsCacheDirty = true;
    this._initialize();
  }
  return _createClass(GeoManager, [{
    key: "_initialize",
    value: function _initialize() {
      var _this = this;
      var geometryTypes = Object.values(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY_TYPES);
      geometryTypes.forEach(function (type) {
        _this.indexByType[type] = [];
        _this.stats.countByType[type] = 0;
      });
      console.log('✅ GeoManager inicializado');
    }

    /**
     * Adiciona uma geometria
     * @param {Object} feature - Feature GeoJSON
     * @param {Object} options - Opções adicionais
     * @returns {string|null} UUID da geometria ou null se inválida
     */
  }, {
    key: "addGeometry",
    value: function addGeometry(feature) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this._validateFeature(feature)) {
        console.error('❌ GeoManager: Feature inválida');
        return null;
      }
      var uuid = options.uuid || this._generateUUID();
      if (this.geometries[uuid]) {
        return this._updateExistingGeometry(uuid, feature, options);
      }
      var geometryType = feature.geometry.type;
      var geometryData = {
        uuid: uuid,
        feature: this._deepClone(feature),
        type: geometryType,
        leafletLayer: null,
        style: options.style || {},
        metadata: options.metadata || {},
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        properties: feature.properties || {}
      };
      this.geometries[uuid] = geometryData;
      this.indexByUUID[uuid] = geometryData;
      this._addToTypeIndex(geometryType, uuid);
      this.stats.totalCount++;
      this.stats.countByType[geometryType]++;
      this._boundsCacheDirty = true;
      return uuid;
    }

    /**
     * Adiciona múltiplas geometrias em batch
     * @param {Array} features - Array de Features GeoJSON
     * @param {Object} options - Opções adicionais
     * @returns {Array} Array de UUIDs adicionados
     */
  }, {
    key: "addGeometriesBatch",
    value: function addGeometriesBatch(features) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!Array.isArray(features)) return [];
      var addedUUIDs = [];
      features.forEach(function (feature) {
        var uuid = _this2.addGeometry(feature, options);
        if (uuid) addedUUIDs.push(uuid);
      });
      return addedUUIDs;
    }

    /**
     * Obtém uma geometria pelo UUID
     * @param {string} uuid - UUID da geometria
     * @returns {Object|null} Dados da geometria ou null
     */
  }, {
    key: "getGeometryByUUID",
    value: function getGeometryByUUID(uuid) {
      return this.geometries[uuid] || null;
    }

    /**
     * Obtém todas as geometrias
     * @param {Object} options - Opções de filtro
     * @returns {Array} Array de geometrias
     */
  }, {
    key: "getAllGeometries",
    value: function getAllGeometries() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var geometries = Object.values(this.geometries);
      if (options.type) {
        geometries = geometries.filter(function (g) {
          return g.type === options.type;
        });
      }
      if (options.sortBy === 'createdAt') {
        geometries.sort(function (a, b) {
          return new Date(a.createdAt) - new Date(b.createdAt);
        });
      }
      if (options.limit) {
        geometries = geometries.slice(0, options.limit);
      }
      return geometries;
    }

    /**
     * Obtém geometrias filtradas por tipo
     * @param {string} type - Tipo de geometria
     * @returns {Array} Array de geometrias do tipo
     */
  }, {
    key: "getGeometriesByType",
    value: function getGeometriesByType(type) {
      var _this3 = this;
      var uuids = this.indexByType[type] || [];
      return uuids.map(function (uuid) {
        return _this3.geometries[uuid];
      }).filter(function (g) {
        return g;
      });
    }

    /**
     * Obtém UUIDs
     * @param {string} type - Tipo opcional
     * @returns {Array} Array de UUIDs
     */
  }, {
    key: "getUUIDs",
    value: function getUUIDs() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (type) return this.indexByType[type] || [];
      return Object.keys(this.geometries);
    }

    /**
     * Obtém geometrias por propriedade
     * @param {string} propertyKey - Chave
     * @param {*} propertyValue - Valor
     * @returns {Array} Array de geometrias
     */
  }, {
    key: "getGeometriesByProperty",
    value: function getGeometriesByProperty(propertyKey, propertyValue) {
      return Object.values(this.geometries).filter(function (g) {
        return g.properties && g.properties[propertyKey] === propertyValue;
      });
    }

    /**
     * Busca geometrias por regex
     * @param {string} searchTerm - Termo de busca
     * @returns {Array} Array de geometrias encontradas
     */
  }, {
    key: "searchByProperties",
    value: function searchByProperties(searchTerm) {
      var regex = new RegExp(searchTerm, 'i');
      return Object.values(this.geometries).filter(function (g) {
        if (g.properties) {
          return Object.values(g.properties).some(function (val) {
            return regex.test(String(val));
          });
        }
        return false;
      });
    }

    /**
     * Atualiza uma geometria
     * @param {string} uuid - UUID
     * @param {Object} feature - Nova feature
     * @param {Object} options - Opções
     * @returns {boolean} Sucesso
     */
  }, {
    key: "updateGeometry",
    value: function updateGeometry(uuid, feature) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!this.geometries[uuid]) return false;
      if (!this._validateFeature(feature)) return false;
      var oldType = this.geometries[uuid].type;
      var newType = feature.geometry.type;
      if (oldType !== newType) {
        this._removeFromTypeIndex(oldType, uuid);
        this._addToTypeIndex(newType, uuid);
        this.stats.countByType[oldType]--;
        this.stats.countByType[newType]++;
      }
      this.geometries[uuid].feature = this._deepClone(feature);
      this.geometries[uuid].type = newType;
      this.geometries[uuid].properties = feature.properties || {};
      this.geometries[uuid].updatedAt = new Date().toISOString();
      this._boundsCacheDirty = true;
      return true;
    }

    /**
     * Remove uma geometria
     * @param {string} uuid - UUID
     * @returns {boolean} Sucesso
     */
  }, {
    key: "removeGeometry",
    value: function removeGeometry(uuid) {
      if (!this.geometries[uuid]) return false;
      var geometryData = this.geometries[uuid];
      var geometryType = geometryData.type;
      if (geometryData.leafletLayer && geometryData.leafletLayer.remove) {
        geometryData.leafletLayer.remove();
      }
      this._removeFromTypeIndex(geometryType, uuid);
      delete this.geometries[uuid];
      delete this.indexByUUID[uuid];
      this.stats.totalCount--;
      this.stats.countByType[geometryType]--;
      this._boundsCacheDirty = true;
      return true;
    }

    /**
     * Remove múltiplas geometrias em batch
     * @param {Array} uuids - Array de UUIDs
     * @returns {number} Quantidade removida
     */
  }, {
    key: "removeGeometriesBatch",
    value: function removeGeometriesBatch(uuids) {
      var _this4 = this;
      if (!Array.isArray(uuids)) return 0;
      var removedCount = 0;
      uuids.forEach(function (uuid) {
        if (_this4.removeGeometry(uuid)) removedCount++;
      });
      return removedCount;
    }

    /**
     * Limpa todas as geometrias
     * @returns {number} Quantidade removida
     */
  }, {
    key: "clear",
    value: function clear() {
      var _this5 = this;
      Object.values(this.geometries).forEach(function (geometryData) {
        if (geometryData.leafletLayer && geometryData.leafletLayer.remove) {
          geometryData.leafletLayer.remove();
        }
      });
      this.geometries = {};
      this.indexByUUID = {};
      Object.keys(this.indexByType).forEach(function (type) {
        _this5.indexByType[type] = [];
      });
      this.stats.totalCount = 0;
      Object.keys(this.stats.countByType).forEach(function (type) {
        _this5.stats.countByType[type] = 0;
      });
      this._boundsCacheDirty = true;
      return Object.keys(this.geometries).length;
    }

    /**
     * Obtém contagem total
     * @returns {number} Quantidade
     */
  }, {
    key: "getCount",
    value: function getCount() {
      return this.stats.totalCount;
    }

    /**
     * Obtém contagem por tipo
     * @returns {Object} Contagem por tipo
     */
  }, {
    key: "getCountByType",
    value: function getCountByType() {
      return Object.assign({}, this.stats.countByType);
    }

    /**
     * Obtém estatísticas
     * @returns {Object} Estatísticas
     */
  }, {
    key: "getStats",
    value: function getStats() {
      var _this6 = this;
      return {
        totalCount: this.stats.totalCount,
        countByType: Object.assign({}, this.stats.countByType),
        geometryTypes: Object.keys(this.indexByType).filter(function (type) {
          return _this6.stats.countByType[type] > 0;
        })
      };
    }

    /**
     * Verifica se UUID existe
     * @param {string} uuid - UUID
     * @returns {boolean}
     */
  }, {
    key: "hasGeometry",
    value: function hasGeometry(uuid) {
      return !!this.geometries[uuid];
    }

    /**
     * Exporta como GeoJSON
     * @param {Object} options - Opções
     * @returns {Object} FeatureCollection
     */
  }, {
    key: "exportAsGeoJSON",
    value: function exportAsGeoJSON() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var geometries = Object.values(this.geometries);
      if (options.type) {
        geometries = geometries.filter(function (g) {
          return g.type === options.type;
        });
      }
      var features = geometries.map(function (g) {
        if (options.includeMetadata) {
          return Object.assign({}, g.feature, {
            properties: Object.assign({}, g.feature.properties || {}, {
              _beraMapUUID: g.uuid,
              _beraMapType: g.type,
              _beraMapMetadata: g.metadata
            })
          });
        }
        return g.feature;
      });
      return {
        type: 'FeatureCollection',
        features: features,
        metadata: {
          exportedAt: new Date().toISOString(),
          count: features.length,
          generatedBy: 'BeraMap GeoManager'
        }
      };
    }

    /**
     * Calcula bounds
     * @returns {Object|null} Bounds ou null
     */
  }, {
    key: "calculateBounds",
    value: function calculateBounds() {
      if (!this._boundsCacheDirty && this._boundsCache) {
        return this._boundsCache;
      }
      if (this.stats.totalCount === 0) return null;
      var minLat = Infinity,
        minLng = Infinity,
        maxLat = -Infinity,
        maxLng = -Infinity;
      Object.values(this.geometries).forEach(function (g) {
        var coords = g.feature.geometry.coordinates;
        if (g.type === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY_TYPES.POINT) {
          minLng = Math.min(minLng, coords[0]);
          maxLng = Math.max(maxLng, coords[0]);
          minLat = Math.min(minLat, coords[1]);
          maxLat = Math.max(maxLat, coords[1]);
        } else if (g.type === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY_TYPES.LINE_STRING || g.type === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY_TYPES.DRAWING) {
          coords.forEach(function (coord) {
            minLng = Math.min(minLng, coord[0]);
            maxLng = Math.max(maxLng, coord[0]);
            minLat = Math.min(minLat, coord[1]);
            maxLat = Math.max(maxLat, coord[1]);
          });
        } else if (g.type === _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY_TYPES.POLYGON) {
          g.feature.geometry.coordinates[0].forEach(function (coord) {
            minLng = Math.min(minLng, coord[0]);
            maxLng = Math.max(maxLng, coord[0]);
            minLat = Math.min(minLat, coord[1]);
            maxLat = Math.max(maxLat, coord[1]);
          });
        }
      });
      this._boundsCache = {
        minLat: minLat,
        minLng: minLng,
        maxLat: maxLat,
        maxLng: maxLng
      };
      this._boundsCacheDirty = false;
      return this._boundsCache;
    }

    /**
     * Define a camada Leaflet para uma geometria
     * @param {string} uuid - UUID
     * @param {Object} leafletLayer - Camada Leaflet
     * @returns {boolean} Sucesso
     */
  }, {
    key: "setLeafletLayer",
    value: function setLeafletLayer(uuid, leafletLayer) {
      if (!this.geometries[uuid]) return false;
      this.geometries[uuid].leafletLayer = leafletLayer;
      return true;
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_validateFeature",
    value: function _validateFeature(feature) {
      if (!feature || _typeof(feature) !== 'object') return false;
      if (feature.type !== 'Feature') return false;
      if (!feature.geometry || !feature.geometry.type) return false;
      var validTypes = Object.values(_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY_TYPES);
      if (!validTypes.includes(feature.geometry.type)) return false;
      if (!feature.geometry.coordinates || !Array.isArray(feature.geometry.coordinates)) return false;
      return true;
    }
  }, {
    key: "_generateUUID",
    value: function _generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }
  }, {
    key: "_deepClone",
    value: function _deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }, {
    key: "_addToTypeIndex",
    value: function _addToTypeIndex(type, uuid) {
      if (!this.indexByType[type]) {
        this.indexByType[type] = [];
      }
      if (!this.indexByType[type].includes(uuid)) {
        this.indexByType[type].push(uuid);
      }
    }
  }, {
    key: "_removeFromTypeIndex",
    value: function _removeFromTypeIndex(type, uuid) {
      if (this.indexByType[type]) {
        var index = this.indexByType[type].indexOf(uuid);
        if (index > -1) {
          this.indexByType[type].splice(index, 1);
        }
      }
    }
  }, {
    key: "_updateExistingGeometry",
    value: function _updateExistingGeometry(uuid, feature, options) {
      this.updateGeometry(uuid, feature, options);
      return uuid;
    }
  }]);
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoManager);

/***/ }),

/***/ "./assets/js/maps.js":
/*!***************************!*\
  !*** ./assets/js/maps.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseRenderer: () => (/* reexport safe */ _renderers_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_3__.BaseRenderer),
/* harmony export */   BeraMap: () => (/* reexport safe */ _core_BeraMap_js__WEBPACK_IMPORTED_MODULE_0__.BeraMap),
/* harmony export */   CircleRenderer: () => (/* reexport safe */ _renderers_CircleRenderer_js__WEBPACK_IMPORTED_MODULE_7__.CircleRenderer),
/* harmony export */   DEFAULT_CONFIG: () => (/* reexport safe */ _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.DEFAULT_CONFIG),
/* harmony export */   DrawingRenderer: () => (/* reexport safe */ _renderers_DrawingRenderer_js__WEBPACK_IMPORTED_MODULE_8__.DrawingRenderer),
/* harmony export */   EVENTS: () => (/* reexport safe */ _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.EVENTS),
/* harmony export */   EventManager: () => (/* reexport safe */ _managers_EventManager_js__WEBPACK_IMPORTED_MODULE_2__.EventManager),
/* harmony export */   GEOMETRY_TYPES: () => (/* reexport safe */ _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.GEOMETRY_TYPES),
/* harmony export */   GeoManager: () => (/* reexport safe */ _managers_GeoManager_js__WEBPACK_IMPORTED_MODULE_1__.GeoManager),
/* harmony export */   LineRenderer: () => (/* reexport safe */ _renderers_LineRenderer_js__WEBPACK_IMPORTED_MODULE_5__.LineRenderer),
/* harmony export */   PointRenderer: () => (/* reexport safe */ _renderers_PointRenderer_js__WEBPACK_IMPORTED_MODULE_4__.PointRenderer),
/* harmony export */   PolygonRenderer: () => (/* reexport safe */ _renderers_PolygonRenderer_js__WEBPACK_IMPORTED_MODULE_6__.PolygonRenderer),
/* harmony export */   STYLE_PRESETS: () => (/* reexport safe */ _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.STYLE_PRESETS),
/* harmony export */   VERSION: () => (/* reexport safe */ _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.VERSION),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   init: () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var _core_BeraMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/BeraMap.js */ "./assets/js/core/BeraMap.js");
/* harmony import */ var _managers_GeoManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./managers/GeoManager.js */ "./assets/js/managers/GeoManager.js");
/* harmony import */ var _managers_EventManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./managers/EventManager.js */ "./assets/js/managers/EventManager.js");
/* harmony import */ var _renderers_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderers/BaseRenderer.js */ "./assets/js/renderers/BaseRenderer.js");
/* harmony import */ var _renderers_PointRenderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderers/PointRenderer.js */ "./assets/js/renderers/PointRenderer.js");
/* harmony import */ var _renderers_LineRenderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderers/LineRenderer.js */ "./assets/js/renderers/LineRenderer.js");
/* harmony import */ var _renderers_PolygonRenderer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderers/PolygonRenderer.js */ "./assets/js/renderers/PolygonRenderer.js");
/* harmony import */ var _renderers_CircleRenderer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderers/CircleRenderer.js */ "./assets/js/renderers/CircleRenderer.js");
/* harmony import */ var _renderers_DrawingRenderer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderers/DrawingRenderer.js */ "./assets/js/renderers/DrawingRenderer.js");
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/constants.js */ "./assets/js/utils/constants.js");
/**
 * BeraMap - Arquivo de entrada principal
 *
 * Exporta todos os módulos e a função factory para inicialização
 */












/**
 * Factory function para inicializar BeraMap
 * @param {string} containerId - ID do container
 * @param {Object} options - Opções de configuração
 * @returns {BeraMap} Instância do BeraMap
 */
function init(containerId) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new _core_BeraMap_js__WEBPACK_IMPORTED_MODULE_0__.BeraMap(containerId, options);
}

// Exportar tudo para acesso direto


// Exportação padrão com função factory
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  init: init,
  version: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.VERSION,
  BeraMap: _core_BeraMap_js__WEBPACK_IMPORTED_MODULE_0__.BeraMap,
  GeoManager: _managers_GeoManager_js__WEBPACK_IMPORTED_MODULE_1__.GeoManager,
  EventManager: _managers_EventManager_js__WEBPACK_IMPORTED_MODULE_2__.EventManager,
  Renderers: {
    BaseRenderer: _renderers_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_3__.BaseRenderer,
    PointRenderer: _renderers_PointRenderer_js__WEBPACK_IMPORTED_MODULE_4__.PointRenderer,
    LineRenderer: _renderers_LineRenderer_js__WEBPACK_IMPORTED_MODULE_5__.LineRenderer,
    PolygonRenderer: _renderers_PolygonRenderer_js__WEBPACK_IMPORTED_MODULE_6__.PolygonRenderer,
    CircleRenderer: _renderers_CircleRenderer_js__WEBPACK_IMPORTED_MODULE_7__.CircleRenderer,
    DrawingRenderer: _renderers_DrawingRenderer_js__WEBPACK_IMPORTED_MODULE_8__.DrawingRenderer
  },
  Constants: {
    GEOMETRY_TYPES: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.GEOMETRY_TYPES,
    EVENTS: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.EVENTS,
    DEFAULT_CONFIG: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.DEFAULT_CONFIG,
    STYLE_PRESETS: _utils_constants_js__WEBPACK_IMPORTED_MODULE_9__.STYLE_PRESETS
  }
});

/***/ }),

/***/ "./assets/js/renderers/BaseRenderer.js":
/*!*********************************************!*\
  !*** ./assets/js/renderers/BaseRenderer.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseRenderer: () => (/* binding */ BaseRenderer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * BaseRenderer - Classe base para todos os renderers
 *
 * Fornece funcionalidades comuns para todos os tipos de geometria
 * Reduz duplicação de código entre renderers
 */

var BaseRenderer = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {Object} beraMap - Referência à instância BeraMap
   * @param {string} geometryType - Tipo de geometria
   * @param {Object} options - Opções de configuração
   */
  function BaseRenderer(beraMap, geometryType) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, BaseRenderer);
    this.beraMap = beraMap;
    this.geometryType = geometryType;
    this.renderedLayers = {};
    this.config = _objectSpread({
      debug: options.debug || false,
      enablePopup: options.enablePopup !== false,
      enableTooltip: options.enableTooltip !== false
    }, options);
    this.defaultStyle = options.defaultStyle || {};
  }

  /**
   * Remove uma geometria renderizada
   * @param {string} uuid - UUID da geometria
   * @returns {boolean} Sucesso da operação
   */
  return _createClass(BaseRenderer, [{
    key: "remove",
    value: function remove(uuid) {
      if (!this.renderedLayers[uuid]) {
        return false;
      }
      var layer = this.renderedLayers[uuid];
      var layerGroup = this.beraMap._layerGroups[this.geometryType];
      if (layerGroup && layer.remove) {
        layerGroup.removeLayer(layer);
      }
      delete this.renderedLayers[uuid];
      return true;
    }

    /**
     * Remove todas as geometrias renderizadas
     * @returns {number} Quantidade removida
     */
  }, {
    key: "removeAll",
    value: function removeAll() {
      var _this = this;
      var uuids = Object.keys(this.renderedLayers);
      var removedCount = 0;
      uuids.forEach(function (uuid) {
        if (_this.remove(uuid)) {
          removedCount++;
        }
      });
      return removedCount;
    }

    /**
     * Obtém uma camada renderizada
     * @param {string} uuid - UUID da geometria
     * @returns {Object|null} Camada ou null
     */
  }, {
    key: "getLayer",
    value: function getLayer(uuid) {
      return this.renderedLayers[uuid] || null;
    }

    /**
     * Obtém todas as camadas renderizadas
     * @returns {Object} Objeto com todas as camadas
     */
  }, {
    key: "getAllLayers",
    value: function getAllLayers() {
      return Object.assign({}, this.renderedLayers);
    }

    /**
     * Obtém quantidade de geometrias renderizadas
     * @returns {number} Quantidade
     */
  }, {
    key: "getLayerCount",
    value: function getLayerCount() {
      return Object.keys(this.renderedLayers).length;
    }

    /**
     * Limpa todas as camadas
     * @returns {void}
     */
  }, {
    key: "clear",
    value: function clear() {
      this.removeAll();
    }

    /**
     * Define o estilo padrão
     * @param {Object} style - Novo estilo padrão
     * @returns {void}
     */
  }, {
    key: "setDefaultStyle",
    value: function setDefaultStyle(style) {
      this.defaultStyle = Object.assign({}, this.defaultStyle, style);
    }

    /**
     * Obtém o estilo padrão
     * @returns {Object} Cópia do estilo padrão
     */
  }, {
    key: "getDefaultStyle",
    value: function getDefaultStyle() {
      return Object.assign({}, this.defaultStyle);
    }

    /**
     * Ativa/desativa debug
     * @param {boolean} enabled - Ativar ou desativar
     * @returns {void}
     */
  }, {
    key: "setDebug",
    value: function setDebug(enabled) {
      this.config.debug = enabled;
    }

    /**
     * Escapa HTML para segurança
     * @protected
     * @param {string} text - Texto a escapar
     * @returns {string} Texto escapado
     */
  }, {
    key: "_escapeHtml",
    value: function _escapeHtml(text) {
      var div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Valida UUID
     * @protected
     * @param {string} uuid - UUID a validar
     * @returns {boolean} Se é válido
     */
  }, {
    key: "_validateUUID",
    value: function _validateUUID(uuid) {
      var uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      return uuidRegex.test(uuid);
    }

    /**
     * Formata distância para unidade legível
     * @protected
     * @param {number} meters - Distância em metros
     * @returns {string} Distância formatada
     */
  }, {
    key: "_formatDistance",
    value: function _formatDistance(meters) {
      if (meters >= 1000) {
        return (meters / 1000).toFixed(2) + ' km';
      }
      return meters.toFixed(2) + ' m';
    }

    /**
     * Formata área para unidade legível
     * @protected
     * @param {number} areaInSqm - Área em metros quadrados
     * @returns {string} Área formatada
     */
  }, {
    key: "_formatArea",
    value: function _formatArea(areaInSqm) {
      var sqkm = areaInSqm / 1000000;
      if (sqkm >= 1) {
        return sqkm.toFixed(4) + ' km²';
      }
      var hectares = areaInSqm / 10000;
      if (hectares >= 1) {
        return hectares.toFixed(4) + ' ha';
      }
      return areaInSqm.toFixed(2) + ' m²';
    }

    /**
     * Calcula distância entre dois pontos (Haversine)
     * @protected
     * @param {Array} latlng1 - [lat, lng]
     * @param {Array} latlng2 - [lat, lng]
     * @returns {number} Distância em metros
     */
  }, {
    key: "_haversineDistance",
    value: function _haversineDistance(latlng1, latlng2) {
      var R = 6371000; // Raio da Terra em metros
      var φ1 = latlng1[0] * Math.PI / 180;
      var φ2 = latlng2[0] * Math.PI / 180;
      var Δφ = (latlng2[0] - latlng1[0]) * Math.PI / 180;
      var Δλ = (latlng2[1] - latlng1[1]) * Math.PI / 180;
      var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    /**
     * Log com prefixo de debug
     * @protected
     * @param {string} message - Mensagem a logar
     * @returns {void}
     */
  }, {
    key: "_log",
    value: function _log(message) {
      if (this.config.debug) {
        console.log("[".concat(this.geometryType, "Renderer] ").concat(message));
      }
    }

    /**
     * Log de erro com prefixo
     * @protected
     * @param {string} message - Mensagem de erro
     * @returns {void}
     */
  }, {
    key: "_logError",
    value: function _logError(message) {
      console.error("[".concat(this.geometryType, "Renderer] \u274C ").concat(message));
    }
  }]);
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseRenderer);

/***/ }),

/***/ "./assets/js/renderers/CircleRenderer.js":
/*!***********************************************!*\
  !*** ./assets/js/renderers/CircleRenderer.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircleRenderer: () => (/* binding */ CircleRenderer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRenderer.js */ "./assets/js/renderers/BaseRenderer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
/**
 * CircleRenderer - Renderizador de Circles para BeraMap
 *
 * Responsável por renderizar círculos com raio configurável
 */


var CircleRenderer = /*#__PURE__*/function (_BaseRenderer) {
  function CircleRenderer(beraMap) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, CircleRenderer);
    _this = _callSuper(this, CircleRenderer, [beraMap, 'Circle', _objectSpread(_objectSpread({}, options), {}, {
      defaultStyle: {
        color: options.defaultColor || '#ff7800',
        weight: options.defaultWeight || 2,
        opacity: options.defaultOpacity || 0.8,
        fillColor: options.defaultFillColor || '#ff7800',
        fillOpacity: options.defaultFillOpacity || 0.2
      }
    })]);
    _this.config.defaultRadius = options.defaultRadius || 500;
    return _this;
  }

  /**
   * Renderiza um círculo
   * @param {string} uuid - UUID da geometria
   * @param {Object} feature - Feature GeoJSON
   * @param {Object} style - Estilo customizado
   * @returns {Object} Circle renderizado
   */
  _inherits(CircleRenderer, _BaseRenderer);
  return _createClass(CircleRenderer, [{
    key: "render",
    value: function render(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!uuid || !feature) {
        this._logError('uuid e feature obrigatórios');
        return null;
      }
      try {
        var _feature$geometry$pro, _feature$properties;
        if (this.renderedLayers[uuid]) {
          this.remove(uuid);
        }
        var coordinates = feature.geometry.coordinates;
        var latLng = [coordinates[1], coordinates[0]];

        // Obter raio
        var radius = this.config.defaultRadius;
        if ((_feature$geometry$pro = feature.geometry.properties) !== null && _feature$geometry$pro !== void 0 && _feature$geometry$pro.radius) {
          radius = feature.geometry.properties.radius;
        } else if ((_feature$properties = feature.properties) !== null && _feature$properties !== void 0 && _feature$properties.radius) {
          radius = feature.properties.radius;
        }
        if (radius <= 0) {
          this._logError('raio deve ser maior que 0');
          return null;
        }
        var finalStyle = Object.assign({}, this.defaultStyle, style);
        var L = window.L;
        var circle = L.circle(latLng, {
          radius: radius,
          color: finalStyle.color,
          weight: finalStyle.weight,
          opacity: finalStyle.opacity,
          fillColor: finalStyle.fillColor,
          fillOpacity: finalStyle.fillOpacity
        });
        var layerGroup = this.beraMap._layerGroups[this.geometryType];
        if (layerGroup) {
          circle.addTo(layerGroup);
        }
        this.renderedLayers[uuid] = circle;
        this.beraMap._geoManager.setLeafletLayer(uuid, circle);

        // Armazenar metadados
        circle._beraMetadata = {
          uuid: uuid,
          feature: feature,
          style: finalStyle,
          latLng: latLng,
          radius: radius,
          area: this._calculateArea(radius),
          circumference: this._calculateCircumference(radius)
        };
        this._attachEventListeners(circle, uuid, feature);
        this._log("Circle renderizado: ".concat(uuid));
        return circle;
      } catch (error) {
        this._logError("Erro ao renderizar: ".concat(error.message));
        return null;
      }
    }

    /**
     * Renderiza múltiplos círculos
     * @param {Array} geometries - Array de { uuid, feature }
     * @param {Object} style - Estilo customizado
     * @returns {Array} Circles renderizados
     */
  }, {
    key: "renderBatch",
    value: function renderBatch(geometries) {
      var _this2 = this;
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rendered = [];
      geometries.forEach(function (_ref) {
        var uuid = _ref.uuid,
          feature = _ref.feature;
        var layer = _this2.render(uuid, feature, style);
        if (layer) rendered.push(layer);
      });
      return rendered;
    }

    /**
     * Atualiza um círculo
     * @param {string} uuid - UUID
     * @param {Object} feature - Nova feature
     * @param {Object} style - Novo estilo
     * @returns {Object} Circle atualizado
     */
  }, {
    key: "update",
    value: function update(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.remove(uuid);
      return this.render(uuid, feature, style);
    }

    /**
     * Obtém a área de um círculo
     * @param {string} uuid - UUID
     * @returns {number|null} Área em metros quadrados
     */
  }, {
    key: "getArea",
    value: function getArea(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.area;
      }
      return null;
    }

    /**
     * Obtém a circunferência de um círculo
     * @param {string} uuid - UUID
     * @returns {number|null} Circunferência em metros
     */
  }, {
    key: "getCircumference",
    value: function getCircumference(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.circumference;
      }
      return null;
    }

    /**
     * Obtém metadados do círculo
     * @param {string} uuid - UUID
     * @returns {Object|null} Metadados
     */
  }, {
    key: "getMetadata",
    value: function getMetadata(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return Object.assign({}, this.renderedLayers[uuid]._beraMetadata);
      }
      return null;
    }

    /**
     * Verifica se um ponto está dentro do círculo
     * @param {string} uuid - UUID
     * @param {number} lat - Latitude
     * @param {number} lng - Longitude
     * @returns {boolean} Se o ponto está dentro
     */
  }, {
    key: "isPointInCircle",
    value: function isPointInCircle(uuid, lat, lng) {
      if (!this.renderedLayers[uuid]) {
        return false;
      }
      var metadata = this.renderedLayers[uuid]._beraMetadata;
      var centerLat = metadata.latLng[0];
      var centerLng = metadata.latLng[1];
      var radius = metadata.radius;
      var distance = this._haversineDistance([lat, lng], [centerLat, centerLng]);
      return distance <= radius;
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_attachEventListeners",
    value: function _attachEventListeners(circle, uuid, feature) {
      var _this3 = this;
      // Click
      circle.on('click', function (e) {
        var geometryData = _this3.beraMap._geoManager.getGeometryByUUID(uuid);
        _this3.beraMap._eventManager.triggerGeometryClicked(uuid, geometryData, e);
        _this3._log("Circle clicado: ".concat(uuid));
      });

      // Mouseover
      circle.on('mouseover', function (e) {
        var geometryData = _this3.beraMap._geoManager.getGeometryByUUID(uuid);
        _this3.beraMap._eventManager.triggerGeometryHovered(uuid, geometryData);
        circle.setStyle({
          weight: _this3.defaultStyle.weight + 2,
          opacity: 1,
          fillOpacity: _this3.defaultStyle.fillOpacity + 0.2
        });
      });

      // Mouseout
      circle.on('mouseout', function (e) {
        var geometryData = _this3.beraMap._geoManager.getGeometryByUUID(uuid);
        _this3.beraMap._eventManager.triggerGeometryUnhovered(uuid, geometryData);
        circle.setStyle({
          weight: _this3.defaultStyle.weight,
          opacity: _this3.defaultStyle.opacity,
          fillOpacity: _this3.defaultStyle.fillOpacity
        });
      });
    }
  }, {
    key: "_calculateArea",
    value: function _calculateArea(radius) {
      return Math.PI * radius * radius;
    }
  }, {
    key: "_calculateCircumference",
    value: function _calculateCircumference(radius) {
      return 2 * Math.PI * radius;
    }
  }]);
}(_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__.BaseRenderer);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleRenderer);

/***/ }),

/***/ "./assets/js/renderers/DrawingRenderer.js":
/*!************************************************!*\
  !*** ./assets/js/renderers/DrawingRenderer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawingRenderer: () => (/* binding */ DrawingRenderer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRenderer.js */ "./assets/js/renderers/BaseRenderer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
/**
 * DrawingRenderer - Renderizador de Drawings para BeraMap
 *
 * Responsável por renderizar desenhos (linhas abertas ou fechadas)
 */


var DrawingRenderer = /*#__PURE__*/function (_BaseRenderer) {
  function DrawingRenderer(beraMap) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, DrawingRenderer);
    _this = _callSuper(this, DrawingRenderer, [beraMap, 'Drawing', _objectSpread(_objectSpread({}, options), {}, {
      defaultStyle: {
        color: options.defaultColor || '#9c27b0',
        weight: options.defaultWeight || 2,
        opacity: options.defaultOpacity || 0.9,
        dashArray: options.defaultDashArray || '5, 5',
        lineCap: options.lineCap || 'round',
        lineJoin: options.lineJoin || 'round'
      }
    })]);
    _this.config.closedLineThreshold = options.closedLineThreshold || 0.00001;
    _this.config.autoDetectClosed = options.autoDetectClosed !== false;
    return _this;
  }

  /**
   * Renderiza um desenho
   * @param {string} uuid - UUID da geometria
   * @param {Object} feature - Feature GeoJSON
   * @param {Object} style - Estilo customizado
   * @returns {Object} Polyline ou Polygon renderizado
   */
  _inherits(DrawingRenderer, _BaseRenderer);
  return _createClass(DrawingRenderer, [{
    key: "render",
    value: function render(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!uuid || !feature) {
        this._logError('uuid e feature obrigatórios');
        return null;
      }
      try {
        if (this.renderedLayers[uuid]) {
          this.remove(uuid);
        }
        var coordinates = feature.geometry.coordinates;
        var latLngs = coordinates.map(function (coord) {
          return [coord[1], coord[0]];
        });

        // Verificar se é fechado
        var isClosed = this._isClosedLine(latLngs);
        var finalStyle = Object.assign({}, this.defaultStyle, style);
        var L = window.L;
        var layer;
        if (isClosed && this.config.autoDetectClosed) {
          // Renderizar como polygon se estiver fechado
          layer = L.polygon(latLngs, {
            color: finalStyle.color,
            weight: finalStyle.weight,
            opacity: finalStyle.opacity,
            fillColor: finalStyle.color,
            fillOpacity: 0.2,
            dashArray: finalStyle.dashArray,
            lineCap: finalStyle.lineCap,
            lineJoin: finalStyle.lineJoin
          });
        } else {
          // Renderizar como polyline se estiver aberto
          layer = L.polyline(latLngs, {
            color: finalStyle.color,
            weight: finalStyle.weight,
            opacity: finalStyle.opacity,
            dashArray: finalStyle.dashArray,
            lineCap: finalStyle.lineCap,
            lineJoin: finalStyle.lineJoin
          });
        }
        var layerGroup = this.beraMap._layerGroups[this.geometryType];
        if (layerGroup) {
          layer.addTo(layerGroup);
        }
        this.renderedLayers[uuid] = layer;
        this.beraMap._geoManager.setLeafletLayer(uuid, layer);

        // Armazenar metadados
        layer._beraMetadata = {
          uuid: uuid,
          feature: feature,
          style: finalStyle,
          isClosed: isClosed,
          length: this._calculateLength(latLngs),
          area: isClosed ? this._calculateArea(latLngs) : null,
          type: isClosed ? 'polygon' : 'polyline'
        };
        this._attachEventListeners(layer, uuid, feature);
        this._log("Drawing renderizado: ".concat(uuid, " (").concat(isClosed ? 'fechado' : 'aberto', ")"));
        return layer;
      } catch (error) {
        this._logError("Erro ao renderizar: ".concat(error.message));
        return null;
      }
    }

    /**
     * Renderiza múltiplos desenhos
     * @param {Array} geometries - Array de { uuid, feature }
     * @param {Object} style - Estilo customizado
     * @returns {Array} Layers renderizados
     */
  }, {
    key: "renderBatch",
    value: function renderBatch(geometries) {
      var _this2 = this;
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rendered = [];
      geometries.forEach(function (_ref) {
        var uuid = _ref.uuid,
          feature = _ref.feature;
        var layer = _this2.render(uuid, feature, style);
        if (layer) rendered.push(layer);
      });
      return rendered;
    }

    /**
     * Atualiza um desenho
     * @param {string} uuid - UUID
     * @param {Object} feature - Nova feature
     * @param {Object} style - Novo estilo
     * @returns {Object} Layer atualizado
     */
  }, {
    key: "update",
    value: function update(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.remove(uuid);
      return this.render(uuid, feature, style);
    }

    /**
     * Obtém o comprimento de um desenho
     * @param {string} uuid - UUID
     * @returns {number|null} Comprimento em metros
     */
  }, {
    key: "getLength",
    value: function getLength(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.length;
      }
      return null;
    }

    /**
     * Obtém a área de um desenho (se fechado)
     * @param {string} uuid - UUID
     * @returns {number|null} Área em metros quadrados
     */
  }, {
    key: "getArea",
    value: function getArea(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.area;
      }
      return null;
    }

    /**
     * Verifica se um desenho está fechado
     * @param {string} uuid - UUID
     * @returns {boolean|null} Se está fechado
     */
  }, {
    key: "isClosed",
    value: function isClosed(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.isClosed;
      }
      return null;
    }

    /**
     * Obtém metadados do desenho
     * @param {string} uuid - UUID
     * @returns {Object|null} Metadados
     */
  }, {
    key: "getMetadata",
    value: function getMetadata(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return Object.assign({}, this.renderedLayers[uuid]._beraMetadata);
      }
      return null;
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_attachEventListeners",
    value: function _attachEventListeners(layer, uuid, feature) {
      var _this3 = this;
      // Click
      layer.on('click', function (e) {
        var geometryData = _this3.beraMap._geoManager.getGeometryByUUID(uuid);
        _this3.beraMap._eventManager.triggerGeometryClicked(uuid, geometryData, e);
        _this3._log("Drawing clicado: ".concat(uuid));
      });

      // Mouseover
      layer.on('mouseover', function () {
        var geometryData = _this3.beraMap._geoManager.getGeometryByUUID(uuid);
        _this3.beraMap._eventManager.triggerGeometryHovered(uuid, geometryData);
        layer.setStyle({
          weight: _this3.defaultStyle.weight + 2,
          opacity: 1
        });
      });

      // Mouseout
      layer.on('mouseout', function () {
        var geometryData = _this3.beraMap._geoManager.getGeometryByUUID(uuid);
        _this3.beraMap._eventManager.triggerGeometryUnhovered(uuid, geometryData);
        layer.setStyle({
          weight: _this3.defaultStyle.weight,
          opacity: _this3.defaultStyle.opacity
        });
      });
    }
  }, {
    key: "_isClosedLine",
    value: function _isClosedLine(latLngs) {
      if (latLngs.length < 3) return false;
      var first = latLngs[0];
      var last = latLngs[latLngs.length - 1];
      var latDiff = Math.abs(first[0] - last[0]);
      var lngDiff = Math.abs(first[1] - last[1]);
      return latDiff < this.config.closedLineThreshold && lngDiff < this.config.closedLineThreshold;
    }
  }, {
    key: "_calculateLength",
    value: function _calculateLength(latLngs) {
      var totalDistance = 0;
      for (var i = 0; i < latLngs.length - 1; i++) {
        totalDistance += this._haversineDistance(latLngs[i], latLngs[i + 1]);
      }
      return totalDistance;
    }
  }, {
    key: "_calculateArea",
    value: function _calculateArea(latLngs) {
      // Fórmula de Shoelace simplificada
      var area = 0;
      var R = 6371000; // Raio da Terra em metros

      for (var i = 0; i < latLngs.length - 1; i++) {
        var p1 = latLngs[i];
        var p2 = latLngs[i + 1];
        var φ1 = p1[0] * Math.PI / 180;
        var φ2 = p2[0] * Math.PI / 180;
        var Δλ = (p2[1] - p1[1]) * Math.PI / 180;
        area += Math.sin(φ1) * Math.cos(φ2) * Math.sin(Δλ);
        area -= Math.sin(φ2) * Math.cos(φ1) * Math.sin(Δλ);
      }
      area = Math.abs(area * R * R) / 2;
      return area;
    }
  }]);
}(_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__.BaseRenderer);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawingRenderer);

/***/ }),

/***/ "./assets/js/renderers/LineRenderer.js":
/*!*********************************************!*\
  !*** ./assets/js/renderers/LineRenderer.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineRenderer: () => (/* binding */ LineRenderer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRenderer.js */ "./assets/js/renderers/BaseRenderer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
/**
 * LineRenderer - Renderizador de LineStrings para BeraMap
 *
 * Responsável por renderizar linhas como polylines Leaflet
 */


var LineRenderer = /*#__PURE__*/function (_BaseRenderer) {
  function LineRenderer(beraMap) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, LineRenderer);
    return _callSuper(this, LineRenderer, [beraMap, 'LineString', _objectSpread(_objectSpread({}, options), {}, {
      defaultStyle: {
        color: options.defaultColor || '#ff7800',
        weight: options.defaultWeight || 3,
        opacity: options.defaultOpacity || 0.8,
        lineCap: options.lineCap || 'round',
        lineJoin: options.lineJoin || 'round'
      }
    })]);
  }

  /**
   * Renderiza uma linha
   * @param {string} uuid - UUID da geometria
   * @param {Object} feature - Feature GeoJSON
   * @param {Object} style - Estilo customizado
   * @returns {Object} Polyline renderizado
   */
  _inherits(LineRenderer, _BaseRenderer);
  return _createClass(LineRenderer, [{
    key: "render",
    value: function render(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!uuid || !feature) {
        this._logError('uuid e feature obrigatórios');
        return null;
      }
      try {
        if (this.renderedLayers[uuid]) {
          this.remove(uuid);
        }
        var coordinates = feature.geometry.coordinates;
        var latLngs = coordinates.map(function (coord) {
          return [coord[1], coord[0]];
        });
        var finalStyle = Object.assign({}, this.defaultStyle, style);
        var L = window.L;
        var polyline = L.polyline(latLngs, {
          color: finalStyle.color,
          weight: finalStyle.weight,
          opacity: finalStyle.opacity,
          lineCap: finalStyle.lineCap,
          lineJoin: finalStyle.lineJoin
        });
        var layerGroup = this.beraMap._layerGroups[this.geometryType];
        if (layerGroup) {
          polyline.addTo(layerGroup);
        }
        this.renderedLayers[uuid] = polyline;
        this.beraMap._geoManager.setLeafletLayer(uuid, polyline);

        // Armazenar metadados
        polyline._beraMetadata = {
          uuid: uuid,
          feature: feature,
          style: finalStyle,
          length: this._calculateLength(latLngs)
        };
        this._attachEventListeners(polyline, uuid, feature);
        this._log("LineString renderizado: ".concat(uuid));
        return polyline;
      } catch (error) {
        this._logError("Erro ao renderizar: ".concat(error.message));
        return null;
      }
    }

    /**
     * Renderiza múltiplas linhas
     * @param {Array} geometries - Array de { uuid, feature }
     * @param {Object} style - Estilo customizado
     * @returns {Array} Polylines renderizados
     */
  }, {
    key: "renderBatch",
    value: function renderBatch(geometries) {
      var _this = this;
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rendered = [];
      geometries.forEach(function (_ref) {
        var uuid = _ref.uuid,
          feature = _ref.feature;
        var layer = _this.render(uuid, feature, style);
        if (layer) rendered.push(layer);
      });
      return rendered;
    }

    /**
     * Atualiza uma linha
     * @param {string} uuid - UUID
     * @param {Object} feature - Nova feature
     * @param {Object} style - Novo estilo
     * @returns {Object} Polyline atualizado
     */
  }, {
    key: "update",
    value: function update(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.remove(uuid);
      return this.render(uuid, feature, style);
    }

    /**
     * Obtém o comprimento de uma linha
     * @param {string} uuid - UUID
     * @returns {number|null} Comprimento em metros
     */
  }, {
    key: "getLength",
    value: function getLength(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.length;
      }
      return null;
    }

    /**
     * Obtém metadados da linha
     * @param {string} uuid - UUID
     * @returns {Object|null} Metadados
     */
  }, {
    key: "getMetadata",
    value: function getMetadata(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return Object.assign({}, this.renderedLayers[uuid]._beraMetadata);
      }
      return null;
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_attachEventListeners",
    value: function _attachEventListeners(polyline, uuid, feature) {
      var _this2 = this;
      // Click
      polyline.on('click', function (e) {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryClicked(uuid, geometryData, e);
        _this2._log("LineString clicado: ".concat(uuid));
      });

      // Mouseover
      polyline.on('mouseover', function () {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryHovered(uuid, geometryData);
        polyline.setStyle({
          weight: _this2.defaultStyle.weight + 2,
          opacity: 1
        });
      });

      // Mouseout
      polyline.on('mouseout', function () {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryUnhovered(uuid, geometryData);
        polyline.setStyle({
          weight: _this2.defaultStyle.weight,
          opacity: _this2.defaultStyle.opacity
        });
      });
    }
  }, {
    key: "_calculateLength",
    value: function _calculateLength(latLngs) {
      var totalDistance = 0;
      for (var i = 0; i < latLngs.length - 1; i++) {
        totalDistance += this._haversineDistance(latLngs[i], latLngs[i + 1]);
      }
      return totalDistance;
    }
  }]);
}(_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__.BaseRenderer);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineRenderer);

/***/ }),

/***/ "./assets/js/renderers/PointRenderer.js":
/*!**********************************************!*\
  !*** ./assets/js/renderers/PointRenderer.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointRenderer: () => (/* binding */ PointRenderer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRenderer.js */ "./assets/js/renderers/BaseRenderer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
/**
 * PointRenderer - Renderizador de Points para BeraMap
 *
 * Responsável por renderizar pontos como markers Leaflet com
 * interatividade e estilos configuráveis
 */


var PointRenderer = /*#__PURE__*/function (_BaseRenderer) {
  function PointRenderer(beraMap) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, PointRenderer);
    return _callSuper(this, PointRenderer, [beraMap, 'Point', _objectSpread(_objectSpread({}, options), {}, {
      defaultStyle: {
        color: options.defaultColor || '#3388ff',
        radius: options.defaultRadius || 5,
        fillOpacity: options.fillOpacity || 0.8
      }
    })]);
  }

  /**
   * Renderiza um ponto
   * @param {string} uuid - UUID da geometria
   * @param {Object} feature - Feature GeoJSON
   * @param {Object} style - Estilo customizado
   * @returns {Object} Marker renderizado
   */
  _inherits(PointRenderer, _BaseRenderer);
  return _createClass(PointRenderer, [{
    key: "render",
    value: function render(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!uuid || !feature) {
        this._logError('uuid e feature obrigatórios');
        return null;
      }
      try {
        if (this.renderedLayers[uuid]) {
          this.remove(uuid);
        }
        var coordinates = feature.geometry.coordinates;
        var latLng = [coordinates[1], coordinates[0]]; // [lng, lat] → [lat, lng]

        var L = window.L;
        var marker = L.marker(latLng);
        var layerGroup = this.beraMap._layerGroups[this.geometryType];
        if (layerGroup) {
          marker.addTo(layerGroup);
        }
        this.renderedLayers[uuid] = marker;
        this.beraMap._geoManager.setLeafletLayer(uuid, marker);

        // Armazenar metadados
        marker._beraMetadata = {
          uuid: uuid,
          feature: feature,
          latLng: latLng
        };
        this._attachEventListeners(marker, uuid, feature);
        this._log("Point renderizado: ".concat(uuid));
        return marker;
      } catch (error) {
        this._logError("Erro ao renderizar: ".concat(error.message));
        return null;
      }
    }

    /**
     * Renderiza múltiplos pontos
     * @param {Array} geometries - Array de { uuid, feature }
     * @param {Object} style - Estilo customizado
     * @returns {Array} Markers renderizados
     */
  }, {
    key: "renderBatch",
    value: function renderBatch(geometries) {
      var _this = this;
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rendered = [];
      geometries.forEach(function (_ref) {
        var uuid = _ref.uuid,
          feature = _ref.feature;
        var layer = _this.render(uuid, feature, style);
        if (layer) rendered.push(layer);
      });
      return rendered;
    }

    /**
     * Atualiza um ponto
     * @param {string} uuid - UUID
     * @param {Object} feature - Nova feature
     * @param {Object} style - Novo estilo
     * @returns {Object} Marker atualizado
     */
  }, {
    key: "update",
    value: function update(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.remove(uuid);
      return this.render(uuid, feature, style);
    }

    /**
     * Obtém metadados do ponto
     * @param {string} uuid - UUID
     * @returns {Object|null} Metadados
     */
  }, {
    key: "getMetadata",
    value: function getMetadata(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return Object.assign({}, this.renderedLayers[uuid]._beraMetadata);
      }
      return null;
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_attachEventListeners",
    value: function _attachEventListeners(marker, uuid, feature) {
      var _this2 = this;
      // Click
      marker.on('click', function (e) {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryClicked(uuid, geometryData, e);
        _this2._log("Point clicado: ".concat(uuid));
      });

      // Mouseover
      marker.on('mouseover', function (e) {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryHovered(uuid, geometryData);
        marker.setOpacity(0.7);
      });

      // Mouseout
      marker.on('mouseout', function (e) {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryUnhovered(uuid, geometryData);
        marker.setOpacity(1);
      });
    }
  }]);
}(_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__.BaseRenderer);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PointRenderer);

/***/ }),

/***/ "./assets/js/renderers/PolygonRenderer.js":
/*!************************************************!*\
  !*** ./assets/js/renderers/PolygonRenderer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolygonRenderer: () => (/* binding */ PolygonRenderer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseRenderer.js */ "./assets/js/renderers/BaseRenderer.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
/**
 * PolygonRenderer - Renderizador de Polygons para BeraMap
 *
 * Responsável por renderizar polígonos como polygons Leaflet
 */


var PolygonRenderer = /*#__PURE__*/function (_BaseRenderer) {
  function PolygonRenderer(beraMap) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, PolygonRenderer);
    return _callSuper(this, PolygonRenderer, [beraMap, 'Polygon', _objectSpread(_objectSpread({}, options), {}, {
      defaultStyle: {
        color: options.defaultColor || '#3388ff',
        weight: options.defaultWeight || 2,
        opacity: options.defaultOpacity || 0.8,
        fillColor: options.defaultFillColor || '#3388ff',
        fillOpacity: options.defaultFillOpacity || 0.2
      }
    })]);
  }

  /**
   * Renderiza um polígono
   * @param {string} uuid - UUID da geometria
   * @param {Object} feature - Feature GeoJSON
   * @param {Object} style - Estilo customizado
   * @returns {Object} Polygon renderizado
   */
  _inherits(PolygonRenderer, _BaseRenderer);
  return _createClass(PolygonRenderer, [{
    key: "render",
    value: function render(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!uuid || !feature) {
        this._logError('uuid e feature obrigatórios');
        return null;
      }
      try {
        if (this.renderedLayers[uuid]) {
          this.remove(uuid);
        }
        var coordinates = feature.geometry.coordinates[0];
        var latLngs = coordinates.map(function (coord) {
          return [coord[1], coord[0]];
        });
        var finalStyle = Object.assign({}, this.defaultStyle, style);
        var L = window.L;
        var polygon = L.polygon(latLngs, {
          color: finalStyle.color,
          weight: finalStyle.weight,
          opacity: finalStyle.opacity,
          fillColor: finalStyle.fillColor,
          fillOpacity: finalStyle.fillOpacity
        });
        var layerGroup = this.beraMap._layerGroups[this.geometryType];
        if (layerGroup) {
          polygon.addTo(layerGroup);
        }
        this.renderedLayers[uuid] = polygon;
        this.beraMap._geoManager.setLeafletLayer(uuid, polygon);

        // Armazenar metadados
        polygon._beraMetadata = {
          uuid: uuid,
          feature: feature,
          style: finalStyle,
          area: this._calculateArea(latLngs),
          perimeter: this._calculatePerimeter(latLngs)
        };
        this._attachEventListeners(polygon, uuid, feature);
        this._log("Polygon renderizado: ".concat(uuid));
        return polygon;
      } catch (error) {
        this._logError("Erro ao renderizar: ".concat(error.message));
        return null;
      }
    }

    /**
     * Renderiza múltiplos polígonos
     * @param {Array} geometries - Array de { uuid, feature }
     * @param {Object} style - Estilo customizado
     * @returns {Array} Polygons renderizados
     */
  }, {
    key: "renderBatch",
    value: function renderBatch(geometries) {
      var _this = this;
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rendered = [];
      geometries.forEach(function (_ref) {
        var uuid = _ref.uuid,
          feature = _ref.feature;
        var layer = _this.render(uuid, feature, style);
        if (layer) rendered.push(layer);
      });
      return rendered;
    }

    /**
     * Atualiza um polígono
     * @param {string} uuid - UUID
     * @param {Object} feature - Nova feature
     * @param {Object} style - Novo estilo
     * @returns {Object} Polygon atualizado
     */
  }, {
    key: "update",
    value: function update(uuid, feature) {
      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.remove(uuid);
      return this.render(uuid, feature, style);
    }

    /**
     * Obtém a área de um polígono
     * @param {string} uuid - UUID
     * @returns {number|null} Área em metros quadrados
     */
  }, {
    key: "getArea",
    value: function getArea(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.area;
      }
      return null;
    }

    /**
     * Obtém o perímetro de um polígono
     * @param {string} uuid - UUID
     * @returns {number|null} Perímetro em metros
     */
  }, {
    key: "getPerimeter",
    value: function getPerimeter(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return this.renderedLayers[uuid]._beraMetadata.perimeter;
      }
      return null;
    }

    /**
     * Obtém metadados do polígono
     * @param {string} uuid - UUID
     * @returns {Object|null} Metadados
     */
  }, {
    key: "getMetadata",
    value: function getMetadata(uuid) {
      if (this.renderedLayers[uuid] && this.renderedLayers[uuid]._beraMetadata) {
        return Object.assign({}, this.renderedLayers[uuid]._beraMetadata);
      }
      return null;
    }

    /**
     * Verifica se um ponto está dentro do polígono
     * @param {string} uuid - UUID
     * @param {number} lat - Latitude
     * @param {number} lng - Longitude
     * @returns {boolean} Se o ponto está dentro
     */
  }, {
    key: "isPointInPolygon",
    value: function isPointInPolygon(uuid, lat, lng) {
      if (!this.renderedLayers[uuid]) {
        return false;
      }
      var polygon = this.renderedLayers[uuid];
      var bounds = polygon.getBounds();

      // Verificação rápida de bounds
      if (!bounds.contains([lat, lng])) {
        return false;
      }

      // Verificação mais precisa com ponto-em-polígono
      var coordinates = this.renderedLayers[uuid]._beraMetadata.feature.geometry.coordinates[0];
      return this._pointInPolygon([lng, lat], coordinates);
    }

    // ===================================================================
    // MÉTODOS PRIVADOS
    // ===================================================================
  }, {
    key: "_attachEventListeners",
    value: function _attachEventListeners(polygon, uuid, feature) {
      var _this2 = this;
      // Click
      polygon.on('click', function (e) {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryClicked(uuid, geometryData, e);
        _this2._log("Polygon clicado: ".concat(uuid));
      });

      // Mouseover
      polygon.on('mouseover', function () {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryHovered(uuid, geometryData);
        polygon.setStyle({
          weight: _this2.defaultStyle.weight + 2,
          opacity: 1,
          fillOpacity: _this2.defaultStyle.fillOpacity + 0.2
        });
      });

      // Mouseout
      polygon.on('mouseout', function () {
        var geometryData = _this2.beraMap._geoManager.getGeometryByUUID(uuid);
        _this2.beraMap._eventManager.triggerGeometryUnhovered(uuid, geometryData);
        polygon.setStyle({
          weight: _this2.defaultStyle.weight,
          opacity: _this2.defaultStyle.opacity,
          fillOpacity: _this2.defaultStyle.fillOpacity
        });
      });
    }
  }, {
    key: "_calculateArea",
    value: function _calculateArea(latLngs) {
      // Fórmula de Shoelace simplificada
      var area = 0;
      var R = 6371000; // Raio da Terra em metros

      for (var i = 0; i < latLngs.length - 1; i++) {
        var p1 = latLngs[i];
        var p2 = latLngs[i + 1];
        var φ1 = p1[0] * Math.PI / 180;
        var φ2 = p2[0] * Math.PI / 180;
        var Δλ = (p2[1] - p1[1]) * Math.PI / 180;
        area += Math.sin(φ1) * Math.cos(φ2) * Math.sin(Δλ);
        area -= Math.sin(φ2) * Math.cos(φ1) * Math.sin(Δλ);
      }
      area = Math.abs(area * R * R) / 2;
      return area;
    }
  }, {
    key: "_calculatePerimeter",
    value: function _calculatePerimeter(latLngs) {
      var totalDistance = 0;
      for (var i = 0; i < latLngs.length; i++) {
        var nextIndex = (i + 1) % latLngs.length;
        totalDistance += this._haversineDistance(latLngs[i], latLngs[nextIndex]);
      }
      return totalDistance;
    }
  }, {
    key: "_pointInPolygon",
    value: function _pointInPolygon(point, polygon) {
      var _point = _slicedToArray(point, 2),
        px = _point[0],
        py = _point[1];
      var inside = false;
      for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        var _polygon$i = _slicedToArray(polygon[i], 2),
          xi = _polygon$i[0],
          yi = _polygon$i[1];
        var _polygon$j = _slicedToArray(polygon[j], 2),
          xj = _polygon$j[0],
          yj = _polygon$j[1];
        var intersect = yi > py !== yj > py && px < (xj - xi) * (py - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    }
  }]);
}(_BaseRenderer_js__WEBPACK_IMPORTED_MODULE_0__.BaseRenderer);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolygonRenderer);

/***/ }),

/***/ "./assets/js/utils/constants.js":
/*!**************************************!*\
  !*** ./assets/js/utils/constants.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_CONFIG: () => (/* binding */ DEFAULT_CONFIG),
/* harmony export */   EVENTS: () => (/* binding */ EVENTS),
/* harmony export */   GEOMETRY_TYPES: () => (/* binding */ GEOMETRY_TYPES),
/* harmony export */   STYLE_PRESETS: () => (/* binding */ STYLE_PRESETS),
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
/**
 * Constants - Constantes globais do BeraMap
 *
 * Centraliza todas as constantes para fácil acesso e manutenção
 */

var GEOMETRY_TYPES = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  CIRCLE: 'Circle',
  DRAWING: 'Drawing'
};
var EVENTS = {
  // Geometrias
  GEOMETRY_ADDED: 'bera:geometryAdded',
  GEOMETRY_UPDATED: 'bera:geometryUpdated',
  GEOMETRY_REMOVED: 'bera:geometryRemoved',
  GEOMETRY_CLICKED: 'bera:geometryClicked',
  GEOMETRY_HOVERED: 'bera:geometryHovered',
  GEOMETRY_UNHOVERED: 'bera:geometryUnhovered',
  // Mapa
  MAP_CLEARED: 'bera:cleared',
  MAP_READY: 'bera:mapReady',
  // Tema
  THEME_CHANGED: 'bera:themeChanged',
  STYLE_CHANGED: 'bera:styleChanged',
  // Seleção
  SELECTION_CHANGED: 'bera:selectionChanged',
  // Erro
  ERROR: 'bera:error'
};
var DEFAULT_CONFIG = {
  center: [-8.7619, -63.9039],
  // Porto Velho, RO
  zoom: 13,
  tileLayer: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  tileAttribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
};
var STYLE_PRESETS = {
  POINT: {
    color: '#3388ff',
    radius: 5,
    fillOpacity: 0.8
  },
  LINE_STRING: {
    color: '#ff7800',
    weight: 3,
    opacity: 0.8
  },
  POLYGON: {
    color: '#3388ff',
    weight: 2,
    opacity: 0.8,
    fillColor: '#3388ff',
    fillOpacity: 0.2
  },
  CIRCLE: {
    color: '#ff7800',
    weight: 2,
    opacity: 0.8,
    fillColor: '#ff7800',
    fillOpacity: 0.2
  },
  DRAWING: {
    color: '#9c27b0',
    weight: 2,
    opacity: 0.9,
    dashArray: '5, 5'
  }
};
var VERSION = '2.0.0-modular';

/***/ }),

/***/ "./assets/sass/maps.scss":
/*!*******************************!*\
  !*** ./assets/sass/maps.scss ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/dist/js/maps.min": 0,
/******/ 			"dist/css/maps.min": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["dist/css/maps.min"], () => (__webpack_require__("./assets/js/maps.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["dist/css/maps.min"], () => (__webpack_require__("./assets/sass/maps.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;