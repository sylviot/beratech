<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mapa de Porto Velho | Leaflet</title>
  <!-- Leaflet CSS -->
  <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
  />
  <!-- Geoman (Leaflet.PM) CSS -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css" />
  <style>
      html, body { height: 100%; margin: 0; }
      #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
      header { padding: .75rem 1rem; border-bottom: 1px solid #e5e7eb; background: #fff; position: sticky; top: 0; z-index: 1000; }
      header h1 { margin: 0; font: 600 16px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
      header .actions { display: flex; gap: .5rem; margin-top: .5rem; flex-wrap: wrap; }
      button { appearance: none; border: 1px solid #e5e7eb; background: #fff; padding: .5rem .75rem; border-radius: .75rem; cursor: pointer; }
      button:hover { background: #f8fafc; }
      #map { width: 100%; height: 100%; }
      .help-card { position: absolute; right: .75rem; bottom: .75rem; z-index: 1001; background: rgba(255,255,255,.95); border: 1px solid #e5e7eb; border-radius: .75rem; padding: .5rem .75rem; max-width: 300px; box-shadow: 0 4px 24px rgba(0,0,0,.08); }
      .help-card small { color: #6b7280; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <h1>Mapa de Porto Velho (Leaflet)</h1>
    <div class="actions">
      <button id="btn-locate" title="Centralizar na sua localiza√ß√£o">üìç Minha localiza√ß√£o</button>
      <button id="btn-reset" title="Voltar para vis√£o inicial">‚Ü∫ Resetar vis√£o</button>
      <button id="btn-draw" title="Desenhar trechos (linhas) no mapa">‚úèÔ∏è Desenhar trechos</button>
      <button id="btn-draw-point" title="Marcar um ponto espec√≠fico">üìå Desenhar ponto</button>
      <button id="btn-draw-polygon" title="Desenhar √°rea (quadra)">‚ñß Desenhar √°rea</button>
      <button id="btn-export" title="Exportar tudo como GeoJSON">üíæ Exportar GeoJSON</button>
      <button id="btn-clear" title="Remover todos os desenhos">üóëÔ∏è Limpar</button>
    </div>
  </header>
  <div id="map"></div>
</div>

<div class="help-card">
  <strong>Dicas r√°pidas</strong>
  <ul style="margin:.25rem 0 .5rem 1rem; padding:0; font-size:12px; color:#374151;">
    <li>‚ñß <b>√Årea/quadra</b>: clique nos v√©rtices e feche clicando no <b>primeiro v√©rtice</b>.</li>
    <li>‚úèÔ∏è <b>Trecho</b>: clique para v√©rtices; <b>duplo clique</b> finaliza. Se terminar colado ao in√≠cio, converto em √°rea.</li>
    <li>üìå <b>Ponto</b>: um clique adiciona um ponto √∫nico no mapa.</li>
    <li>üíæ Exporta <b>linhas</b>, <b>pontos</b> e <b>√°reas</b> como GeoJSON.</li>
  </ul>
  <small>Tiles: ¬© OpenStreetMap, Esri ‚Äî Dados sujeitos a licen√ßas e atribui√ß√µes indicadas.</small>
</div>

<!-- Leaflet JS -->
<script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
></script>
<!-- Geoman (Leaflet.PM) JS -->
<script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>
<script>
  // --- Configura√ß√£o base ---
  const inicial = { centro: [-8.76077, -63.8999], zoom: 13 };

  // Camadas base
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contribs'
  });
  const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    maxZoom: 19,
    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, USGS, IGN, etc.'
  });

  // Mapa
  const map = L.map('map', { center: inicial.centro, zoom: inicial.zoom, layers: [osm], zoomControl: true });

  // Controle de camadas
  const baseMaps = { 'OpenStreetMap': osm, 'Sat√©lite (Esri)': esriSat };
  const overlayMaps = {};
  const layerControl = L.control.layers(baseMaps, overlayMaps, { collapsed: true }).addTo(map);

  // Escala
  L.control.scale({ metric: true, imperial: false }).addTo(map);

  // Grupos
  const trechosGroup = L.layerGroup().addTo(map);
  const pontosGroup  = L.layerGroup().addTo(map);
  const areasGroup   = L.layerGroup().addTo(map);
  layerControl.addOverlay(trechosGroup, 'Trechos desenhados');
  layerControl.addOverlay(pontosGroup,  'Pontos desenhados');
  layerControl.addOverlay(areasGroup,   '√Åreas desenhadas');

  // Helpers
  function comprimentoEmMetros(latlngs) {
    if (!Array.isArray(latlngs)) return 0;
    let d = 0; for (let i = 1; i < latlngs.length; i++) d += map.distance(latlngs[i-1], latlngs[i]);
    return d;
  }
  function formatarMetros(m) { return m >= 1000 ? (m/1000).toFixed(2) + ' km' : Math.round(m) + ' m'; }

  // Click -> coordenadas
  map.on('click', (e) => {
    const { lat, lng } = e.latlng;
    L.popup().setLatLng([lat, lng]).setContent(`Coordenadas:<br><b>${lat.toFixed(6)}, ${lng.toFixed(6)}</b>`).openOn(map);
  });

  // Bot√µes b√°sicos
  document.getElementById('btn-reset').addEventListener('click', () => map.setView(inicial.centro, inicial.zoom));
  let userCircle = null, userMarker = null;
  document.getElementById('btn-locate').addEventListener('click', () => {
    if (!navigator.geolocation) return alert('Geolocaliza√ß√£o n√£o suportada.');
    navigator.geolocation.getCurrentPosition((e) => {
      const { latitude, longitude, accuracy } = e.coords; const pos = [latitude, longitude];
      if (!userMarker) userMarker = L.marker(pos, { title: 'Voc√™ est√° aqui' }).addTo(map); else userMarker.setLatLng(pos);
      if (!userCircle) userCircle = L.circle(pos, { radius: accuracy }).addTo(map); else { userCircle.setLatLng(pos); userCircle.setRadius(accuracy); }
      userMarker.bindPopup('Sua localiza√ß√£o aproximada'); map.setView(pos, 15);
    }, (err) => alert('N√£o foi poss√≠vel obter sua localiza√ß√£o: ' + (err.message||err)), { enableHighAccuracy: true, timeout: 10000, maximumAge: 10000 });
  });

  // --- Geoman (Leaflet.PM) ---
  const pmOK = !!(map.pm && typeof map.pm.addControls === 'function');
  if (pmOK) {
    // Estilo e snapping
    map.pm.setPathOptions({ color: '#d97706', weight: 6, opacity: 0.9 }, { snappable: true, snapDistance: 30, snapSegment: true, snapVertex: true });
    map.pm.addControls({
      position: 'topleft',
      drawMarker: true,
      drawPolygon: true,
      drawPolyline: true,
      editMode: true,
      removalMode: true,
      dragMode: false,
      cutPolygon: false,
      drawCircle: false,
      drawCircleMarker: false,
      drawRectangle: false
    });

    // Registrar cria√ß√µes
    map.on('pm:create', function (e) {
      const layer = e.layer; if (!layer) return;
      // Linha (Polyline)
      if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
        trechosGroup.addLayer(layer);
        const latlngs = layer.getLatLngs();
        const len = comprimentoEmMetros(latlngs);
        // Fechamento inteligente: se √∫ltimo ponto colar no primeiro, vira √°rea
        if (latlngs.length > 2) {
          const start = latlngs[0];
          const end = latlngs[latlngs.length - 1];
          const CLOSE_THRESH = 15; // metros
          if (map.distance(start, end) <= CLOSE_THRESH) {
            const ring = latlngs.slice(0, -1); // remove o √∫ltimo (duplicado do primeiro)
            const poly = L.polygon(ring, { color: '#059669', weight: 3, fillOpacity: 0.25 });
            areasGroup.addLayer(poly); trechosGroup.removeLayer(layer);
            poly.bindPopup('<b>√Årea</b><br>Quadra desenhada');
            return;
          }
        }
        layer.bindPopup('<b>Trecho</b><br>Comprimento: ' + formatarMetros(len));
        return;
      }
      // Pol√≠gono
      if (layer instanceof L.Polygon) {
        areasGroup.addLayer(layer);
        layer.bindPopup('<b>√Årea</b><br>Quadra desenhada');
        return;
      }
      // Ponto
      if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
        pontosGroup.addLayer(layer);
        const { lat, lng } = layer.getLatLng();
        layer.bindPopup('<b>Ponto</b><br>LatLng: ' + lat.toFixed(6) + ', ' + lng.toFixed(6));
        return;
      }
    });

    // Bot√µes custom
    document.getElementById('btn-draw').addEventListener('click', function () {
      map.pm.enableDraw('Line', {
        snappable: true, snapVertex: true, snapSegment: true, snapDistance: 30,
        finishOn: 'dblclick', // finalize com duplo clique
        // requireSnapToFinish ajuda a fechar no v√©rtice, quando for o caso
        requireSnapToFinish: false
      });
    });
    document.getElementById('btn-draw-point').addEventListener('click', function () {
      map.pm.enableDraw('Marker', {});
    });
    document.getElementById('btn-draw-polygon').addEventListener('click', function () {
      map.pm.enableDraw('Polygon', {
        snappable: true, snapVertex: true, snapSegment: true, snapDistance: 30,
        // Com snapping ativado, clicar no primeiro v√©rtice fecha corretamente
        requireSnapToFinish: true
      });
    });
  } else {
    // Fallback se Geoman n√£o carregar
    const warn = () => alert('Leaflet.Geoman n√£o carregou. Desenho indispon√≠vel.');
    ['btn-draw','btn-draw-point','btn-draw-polygon'].forEach(id => { const el = document.getElementById(id); if (el) el.addEventListener('click', warn); });
  }

  // Exportar GeoJSON (linhas + pontos + √°reas)
  document.getElementById('btn-export').addEventListener('click', function () {
    const features = [];
    trechosGroup.eachLayer(layer => { const gj = layer.toGeoJSON(); if (gj?.geometry?.type === 'LineString') features.push(gj); });
    pontosGroup.eachLayer(layer => { const gj = layer.toGeoJSON(); if (gj?.geometry?.type === 'Point') features.push(gj); });
    areasGroup.eachLayer(layer  => { const gj = layer.toGeoJSON(); if (gj?.geometry && (gj.geometry.type === 'Polygon' || gj.geometry.type === 'MultiPolygon')) features.push(gj); });
    if (!features.length) { alert('N√£o h√° elementos para exportar.'); return; }
    const fc = { type: 'FeatureCollection', features };
    return console.warn(JSON.stringify(fc, null, 2));

    const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'desenhos-porto-velho.geojson'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  // Limpar
  document.getElementById('btn-clear').addEventListener('click', function(){ trechosGroup.clearLayers(); pontosGroup.clearLayers(); areasGroup.clearLayers(); });
</script>
</body>
</html>
